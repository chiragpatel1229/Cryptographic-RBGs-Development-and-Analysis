import math

from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.fernet import Fernet
from os import urandom
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.asymmetric.utils import Prehashed


#
# # Example function to compute the gcd (the greatest common divisor)
# def gcd(a, b):
#     if b == 0:
#         return a
#     else:
#         return gcd(b, a % b)
#
#
# # let's calculate some examples using algorithm
# n1 = gcd(50, 10)
# n2 = gcd(99, 33)
# n3 = gcd(59, 9)
#
# # do the same with the python library call
# m1 = math.gcd(50, 10)
# m2 = math.gcd(99, 33)
# m3 = math.gcd(59, 9)
#
# # Confirm they are the same
# assert (n1 == m1)
# assert (n2 == m2)
# assert (n3 == m3)
#
# # They are - print out the values for explanation
# print("gcd(50,10) =", m1)
# print("gcd(99,1033) =", m2)
# print("gcd(59,9) =", m3)
#
# # 0.0 ==================================================================================================================
#
# # Choosing two prime numbers and keep them secret
# p = 13
# q = 19
# print("The secret prime numbers p and q are:", p, q)
#
# # Calculate n which is the modulus for both the public and private keys
# n = p * q
# print("modulus n (p*q)=", n)
#
# # Compute Euler's totient function, φ(n) and keep it secret
# phi = (p-1) * (q-1)
# print("The secret Euler's function (totient) [phi(n)]:", phi)
#
# # 0.0 ==================================================================================================================
# # We are now ready to calculate the public and private keys. In RSA, each of these is specified by a tuple of two integers.
# # The first entry in each tuple is a distinct integer, and the second entry is the modulus n that is common to both keys.
# # The first entry in the public key can be any integer greater than 1 that is co-prime to phi. Two integers are co-prime
# # if their greatest common divisor is 1. So we use the math.gcd function find an integer e co-prime to phi.
# # 0.0 ==================================================================================================================
#
# # Choose an integer e such that e and φ(n) are co-prime
# e = 2
# while e < phi:
#     if math.gcd(e, phi) == 1:
#         break
#     else:
#         e += 1
# print("Public Key (e):", e)
#
#
# # Compute a value for d such that (d * e) % φ(n) = 1
# # In realistic settings, the computationally efficient extended Euclidean algorithm is used for this purpose.
# d = 1
# while True:
#     if (d * e) % phi == 1:
#         break
#     else:
#         d += 1
# print("Private Key (d):", d)
#
# # 0.0 ==================================================================================================================
#
# # Public and Private Key pair
# public = (e, n)
# private = (d, n)
#
# print(f"The Public key is {public} and Private Key is {private}")
#
# # 0.0 ==================================================================================================================
# # 0.0 ==================================================================================================================
# # 0.0 ==================================================================================================================
#
#
# # Encryption function
# def encrypt(plain_text):
#     return (plain_text ** e) % n
#
#
# # Decryption function
# def decrypt(cipher_text):
#     return (cipher_text ** d) % n
#
#
# # Simple message to encode
# msg = 25
#
# # encrypt then decrypt
# enc_msg = encrypt(msg)
# dec_msg = decrypt(enc_msg)
#
# print("Original Message:", msg)
# print("Encrypted Message:", enc_msg)
# print("Decrypted Message:", dec_msg)


# 0.0 ==================================================================================================================
# 0.0 ==================================================================================================================
# 0.0 ==================================================================================================================

symmetric_key = Fernet.generate_key()
print(f"\nSymmetric key generated by Alice: {symmetric_key}")

# Using the rsa module from the cryptography library, Bob generates a key pair and then broadcasts his public key.
# Any one can intercept the public key and read off the public numbers (e,n) that form the key.
# Bob generates a 2048-bit RSA key pair
bob_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
bob_public_key = bob_private_key.public_key()
print(f"Public key broadcast by Bob: {bob_public_key}")
print(f"\nPublic numbers in Bobs' public key: {bob_public_key.public_numbers()}")


# At this point, we assume Alice has received the public key broadcast by Bob.
# she will perform Encryption using Bob's public key to send Bob
ciphertext = bob_public_key.encrypt(symmetric_key, padding.OAEP(
                                           mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                           algorithm=hashes.SHA256(),
                                           label=None))

print("Ciphertext:", ciphertext)

# Bob decrypts ciphertext to access the symmetric key
decrypted_symmetric_key = bob_private_key.decrypt(
   ciphertext,
   padding.OAEP(
       mgf=padding.MGF1(algorithm=hashes.SHA256()),
       algorithm=hashes.SHA256(),
       label=None
   )
)

print("Decrypted key:", decrypted_symmetric_key)
assert decrypted_symmetric_key == symmetric_key

# Now both alice and bob has the same symmetric key access, for secure communication using SKS(symmetric key cryptography)


# 0.0 ==================================================================================================================
# One more time trying to share secret key non-interactively
# 0.0 ==================================================================================================================
# 0.0 ==================================================================================================================

# Bob's RSA key pair
private_key_Bob = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key_Bob = private_key_Bob.public_key()

print("Bob's private and public keys created")

Alice_long_secret = urandom(160)  # A 160 byte or 1280 bit random message
print("Alice's secret created")

Alice_encrypted_secret = public_key_Bob.encrypt(Alice_long_secret, padding.OAEP(
                                                                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                                                algorithm=hashes.SHA256(), label=None))
print("Alice's secret encrypted")

Bob_decrypted_secret = private_key_Bob.decrypt(
    Alice_encrypted_secret,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

assert Alice_long_secret == Bob_decrypted_secret, "Secrets do not match!"

# if we get here they match
print("Secrets match")

# 0.0 ==================================================================================================================
# 0.0 ==================================================================================================================
# 0.0 ==================================================================================================================


def key_derivation_function(secret, salt):
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,  # Desired key length
        salt=salt,
        info=None,
        backend=None
    )
    return hkdf.derive(secret)


common_salt = urandom(16)  # Random salt accessible to both Alice and Bob

symmetric_key_Alice = key_derivation_function(Alice_long_secret, common_salt)
symmetric_key_Bob = key_derivation_function(Bob_decrypted_secret, common_salt)

assert symmetric_key_Alice == symmetric_key_Bob, "Derived keys do not match!"
print(f"A symmetric key of length {len(symmetric_key_Alice)*8} bits was successfully derived by both Alice and Bob!")


# ======================================================================================================================
# Generate keys for Bob
bob_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
bob_public_key = bob_private_key.public_key()

# Generate keys for Alice
alice_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
alice_public_key = alice_private_key.public_key()

print("Private and Public keys generated for Bob and Alice.")
# ======================================================================================================================
# In the next step, as before, Alice uses Bob's public key to encrypt the symmetric key and prepares the ciphertext.
# Alice encrypts the message using Bob's public key
ciphertext = bob_public_key.encrypt(
    symmetric_key,
    padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                 algorithm=hashes.SHA256(), label=None))

print("ciphertext of symmetric key: ", ciphertext)
# ======================================================================================================================
# Create a hash of the ciphertext using a hashing algorithm.
# Encrypt the hash using Alice's private key, which amounts to a signature.

# Alice signs the ciphertext using her private key
digest = hashes.Hash(hashes.SHA256())
digest.update(ciphertext)
hash_to_sign = digest.finalize()

signature = alice_private_key.sign(
    hash_to_sign,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    Prehashed(hashes.SHA256())
)

print("signature: ", signature)
# ======================================================================================================================
# Bob receives the ciphertext and signature
received_ciphertext = ciphertext
received_signature = signature

# Send signature and ciphertext here
print("Sending ciphertext and signature.....")
# ======================================================================================================================
# On Bob's side, the first task is to verify the integrity and authenticity of the ciphertext. To do this, Bob creates a
# hash of the received ciphertext using the same hashing algorithm used by Alice.
# Bob creates a hash of the ciphertext using the same algorithm used by Alice
digest = hashes.Hash(hashes.SHA256())
digest.update(received_ciphertext)
hash_to_verify = digest.finalize()

print("hash to verify: ", hash_to_verify)
# ======================================================================================================================
# Bob verifies the signature using Alice's public key
try:
    alice_public_key.verify(
        received_signature,
        hash_to_verify,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        Prehashed(hashes.SHA256())
    )
    print("The signature is valid.")
except:
    print("The signature is not valid.")
# ======================================================================================================================
# Having verified the integrity and authenticity of the received ciphertext, Bob can then decrypt it using his private
# key because Alice created the ciphertext using Bob's public key.
# Bob decrypts the message using his private key
decrypted_message = bob_private_key.decrypt(
    received_ciphertext,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

print("Decrypted message:", decrypted_message.decode())
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================

