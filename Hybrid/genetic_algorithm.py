import random
import secrets
# Reference: https://in.mathworks.com/help/gads/how-the-genetic-algorithm-works.html
#            https://in.mathworks.com/help/gads/what-is-the-genetic-algorithm.html
#            https://machinelearningmastery.com/simple-genetic-algorithm-from-scratch-in-python/
#            https://github.com/ahmedfgad/GeneticAlgorithmPython/tree/master

# 0.0 =========== initialise the Parameters to set the variable values =================================================
total_population = 30                    # total size of the population of genomes
Bit_length = 32                      # length of each genome (number of bits)
mutation_rate = 0.01                 # probability of mutating each bit
gen = 20                             # it is the number of generations (gen) to run the algorithm


# 1.0 =========== Convert The Data Types to Store ======================================================================
def b2i(data):                                              # convert bytes to a list of integers
    binary_string = ''                                      # Convert each byte to a binary string and join them
    for byte in data:
        binary_string += bin(byte)[2:].zfill(8)             # convert each byte to binary of 8 characters and append
    return binary_string


# 2.0 =========== creating a random initial population: The algorithm then creates a sequence of new populations. At each step,
# =============== the algorithm uses the individuals in the current generation to create the next population. ==========
population = []                                             # create a buffer for storing population
for _ in range(total_population):
    geno = secrets.token_bytes(Bit_length // 8)             # Append a random bit (0 or 1) to the genome
    genome = b2i(geno)                                      # Convert the generated bytes to the binary string
    population.append(genome)                               # prepare the population list


# 3.0 =========== Scales the raw fitness scores to convert them into a more usable range of values. These scaled values are called expectation values.
def fitness(_genome_):
    total = 0                               # Initiate the counter to store the total calculation
    for bit in _genome_:
        total += int(bit)                   # get the total of every available ones in the sequence
    return total                            # Return the total as the fitness score for the current population list


# 4.0 =========== Selects members, called parents, based on their expectation. =========================================
def selection(population_):
    s_p = sorted(population_, key=fitness, reverse=True)  # Sort the population (s_p) using fitness function with descending order
    r_g = random.choice(s_p)                # select a random genome from the sorted population
    return r_g                              # Return the selected genome


# 5.0 =========== Crossover/Reproduction Options: Some-of-the individuals in the current population that have lower fitness are
# =============== chosen as elite. These elite individuals are passed to the next population.
def crossover(p__1, p__2):
    c_p = secrets.randbelow(Bit_length+1)       # Choose a random crossover_point (c_p) to split the genomes
    c__1 = p__1[:c_p] + p__2[c_p:]              # first child (c__1) by combining the first part of parent 1 (p__1) and the second part of parent 2 (p__2)
    c__2 = p__2[:c_p] + p__1[c_p:]              # second child (c__2) by combining the first part of parent 2 (p__2) and the second part of parent 1 (p__1)
    return c__1, c__2


# 6.0 =========== Produces children from the parents. Children are produced either by making random changes to =========
# =============== a single parent—mutation—or by combining the vector entries of a pair of parents—crossover. ==========
# =============== Mutation: Replaces the current population with the children to form the next generation. =============
def mutate(genome_):
    m_g = ''                                    # buffer to store the mutated genome = m_g
    for bit in genome_:
        if random.random() > mutation_rate:     # With a probability of 1 - mutation rate
            m_g += bit                          # add the bit as it is in the mutated genome binary string
        else:
            mutated_bit = str(int(bit) ^ 1)     # else perform the XOR operation with the current bit
            m_g += mutated_bit
    return m_g                                  # Return the mutated genome


# 7.0 =========== Main loop ============================================================================================
for gen in range(gen):                          # Loop for the total number of generations selected by user
    n_p = []                                    # buffer to store the new population = (n_p)
    while len(n_p) < total_population:          # increase the new population to user selected number
        p_1 = selection(population)             # get the first parent (p_1) and second parent(p_2)
        p_2 = selection(population)
        c_1, c_2 = crossover(p_1, p_2)          # use crossover to get two children c_1 and c_2
        m_child1 = mutate(c_1)                  # find mutated child m_child1/2 using existed child
        m_child2 = mutate(c_2)
        n_p.append(m_child1)                    # append the mutated child to the nuw populations
        n_p.append(m_child2)
    population = n_p                            # set the population with the newly found populations


# 8.0 =========== Print the fittest individual from the last generation ===============================================
fittest_individual = selection(population)          # find the final population using the selection function
print(fittest_individual)                           # Print the fittest individual
